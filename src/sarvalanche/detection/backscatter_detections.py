import xarray as xr

from sarvalanche.utils.generators import iter_track_pol_combinations

# from sarvalanche.probabilities.ecdf import compute_track_ecdf_probability
from sarvalanche.probabilities.empirical import compute_track_empirical_probability

from sarvalanche.probabilities.combine import combine_probabilities
from sarvalanche.weights.combinations import combine_weights
from sarvalanche.weights.polarizations import get_polarization_weights

from sarvalanche.utils.validation import validate_weights_sum_to_one
# Empirical pipeline - FULL SCENE
def calculate_empirical_backscatter_probability(ds, avalanche_date, **kwargs):
    """
    Calculate full-scene avalanche probability using empirical backscatter change method.

    Combines probabilities across all track/polarization combinations.
    """
    results = []
    resolution_weights = []
    pol_weights = []
    track_pol_labels = []

    for track, pol, da, weights in iter_track_pol_combinations(ds, include_weights=False):
        p = compute_track_empirical_probability(da, avalanche_date)
        ds[f'p_{track}_{pol}_empirical'] = p
        results.append(p)
        resolution_weights.append(ds['w_resolution'].sel(static_track = track))
        pol_weights.append(get_polarization_weights(pol))
        track_pol_labels.append(f"{track}_{pol}")


    if not results:
        raise ValueError('No results generated by empirical pipeline.')

    probs = xr.concat(results, dim="track_pol")#.assign_coords(track_pol=track_pol_labels)
    resolution_weights = xr.concat(resolution_weights, dim = 'track_pol')#.assign_coords(track_pol=track_pol_labels)
    # Convert pol_weights list of floats to DataArray
    pol_weights = xr.DataArray(
        pol_weights,
        dims=['track_pol'],
        # coords={'track_pol': track_pol_labels},
        name='w_polarization'
    )

    combined_weights = combine_weights(resolution_weights, pol_weights, dim = 'track_pol')

    validate_weights_sum_to_one(combined_weights, 'track_pol')


    # change to combine_probabilities_with_agreement for boosting for agreement.
    # p_empirical = combine_probabilities(probs, weights = orbit_pol_weights, dim='track_pol', method='log_odds', alpha=None)
    p_empirical = (probs * combined_weights).sum(dim='track_pol')

    p_empirical.attrs = {'source': 'sarvalanche', 'units': 'percentage', 'product': 'probability'}
    return p_empirical


# # ECDF pipeline - FULL SCENE
# def calculate_ecdf_backscatter_probability(ds, avalanche_date, **kwargs):
#     """
#     Calculate full-scene avalanche probability using ECDF-based statistical method.

#     Combines probabilities across all track/polarization combinations.
#     """
#     results = []

#     for track, pol, da, lia in iter_track_pol_combinations(ds):
#         p = compute_track_ecdf_probability(da, lia, avalanche_date)
#         results.append(p)

#     if not results:
#         raise ValueError('No results generated by ECDF pipeline.')

#     probs = xr.concat(results, dim="track_pol")

#     return combine_probabilities(probs, dim='track_pol', method='log_odds', alpha=0.5)