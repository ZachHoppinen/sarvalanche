import xarray as xr

from sarvalanche.utils.generators import iter_track_pol_combinations

# from sarvalanche.probabilities.ecdf import compute_track_ecdf_probability
from sarvalanche.probabilities.empirical import compute_track_empirical_probability

from sarvalanche.probabilities.combine import combine_probabilities
from sarvalanche.weights.combinations import combine_weights

from sarvalanche.utils.constants import rtc_pol_confidences
# Empirical pipeline - FULL SCENE
def calculate_empirical_backscatter_probability(ds, avalanche_date, **kwargs):
    """
    Calculate full-scene avalanche probability using empirical backscatter change method.

    Combines probabilities across all track/polarization combinations.
    """
    results = []
    orbit_pol_weights = []

    for track, pol, da, weights in iter_track_pol_combinations(ds, include_weights=False):
        p = compute_track_empirical_probability(da, avalanche_date)
        ds[f'p_{track}_{pol}_empirical'] = p
        results.append(p)
        weight = rtc_pol_confidences[pol] * ds['w_resolution'].sel(static_track = track)
        orbit_pol_weights.append(weight)

    if not results:
        raise ValueError('No results generated by empirical pipeline.')

    probs = xr.concat(results, dim="track_pol")
    orbit_pol_weights = xr.concat(orbit_pol_weights, dim = 'track_pol')

    # change to combine_probabilities_with_agreement for boosting for agreement.
    p_empirical = combine_probabilities(probs, weights = orbit_pol_weights, dim='track_pol', method='log_odds', alpha=None)

    p_empirical.attrs = {'source': 'sarvalanche', 'units': 'percentage', 'product': 'probability'}
    return p_empirical


# # ECDF pipeline - FULL SCENE
# def calculate_ecdf_backscatter_probability(ds, avalanche_date, **kwargs):
#     """
#     Calculate full-scene avalanche probability using ECDF-based statistical method.

#     Combines probabilities across all track/polarization combinations.
#     """
#     results = []

#     for track, pol, da, lia in iter_track_pol_combinations(ds):
#         p = compute_track_ecdf_probability(da, lia, avalanche_date)
#         results.append(p)

#     if not results:
#         raise ValueError('No results generated by ECDF pipeline.')

#     probs = xr.concat(results, dim="track_pol")

#     return combine_probabilities(probs, dim='track_pol', method='log_odds', alpha=0.5)