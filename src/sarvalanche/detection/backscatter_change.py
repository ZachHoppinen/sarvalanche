
import logging
import numpy as np
import xarray as xr

from sarvalanche.utils.generators import iter_track_pol_combinations

log = logging.getLogger(__name__)

# from sarvalanche.probabilities.ecdf import compute_track_ecdf_probability
from sarvalanche.probabilities.empirical import compute_track_empirical_probability

from sarvalanche.probabilities.combine import combine_probabilities
from sarvalanche.weights.combinations import combine_weights, weighted_mean
from sarvalanche.weights.polarizations import get_polarization_weights

from sarvalanche.utils.validation import validate_weights_sum_to_one

# Empirical pipeline - FULL SCENE
def calculate_empirical_backscatter_probability(
    ds: xr.Dataset,
    avalanche_date: np.datetime64,
    use_agreement_boosting: bool,
    agreement_strength: float,
    min_prob_threshold: float,
    validate_weights: bool = True,
    **kwargs
) -> xr.DataArray:
    """
    Calculate full-scene avalanche probability using empirical backscatter change method.

    Combines probabilities across all track/polarization combinations with optional
    agreement boosting.

    Parameters
    ----------
    ds : xr.Dataset
        Dataset containing backscatter data and weights
    avalanche_date : np.datetime64
        Date of avalanche event
    use_agreement_boosting : bool
        If True, boost probability when multiple tracks/pols agree (default: True)
    agreement_strength : float
        How much to boost for full agreement (0.0-1.0, default: 0.8)
        Only used if use_agreement_boosting=True
    min_prob_threshold : float
        Minimum probability to consider as "detection" for agreement (default: 0.1)
        Only used if use_agreement_boosting=True
    validate_weights : bool
        If True, validate that weights sum to 1.0
    **kwargs
        Additional arguments passed to compute_track_empirical_probability

    Returns
    -------
    tuple[xr.DataArray, xr.DataArray]
        ``(p_empirical, d_empirical)`` â€” the combined probability (0-1) and
        the combined weighted-mean backscatter change (dB) across all
        track/pol combinations.  Per-track intermediates are also written
        into ``ds`` as ``p_{track}_{pol}_empirical`` and
        ``d_{track}_{pol}_empirical``.

    Examples
    --------
    >>> # Standard weighted average (no agreement boosting)
    >>> p = calculate_empirical_backscatter_probability(
    ...     ds, avalanche_date, use_agreement_boosting=False
    ... )

    >>> # With agreement boosting (recommended)
    >>> p = calculate_empirical_backscatter_probability(
    ...     ds, avalanche_date, use_agreement_boosting=True, agreement_strength=0.8
    ... )
    """
    prob_results = []
    change_results = []
    resolution_weights = []
    pol_weights = []
    track_pol_labels = []

    log.debug("calculate_empirical_backscatter_probability: starting track/pol iteration")
    for track, pol, da in iter_track_pol_combinations(ds):
        log.debug("Processing track=%s, pol=%s", track, pol)

        p, d = compute_track_empirical_probability(da, avalanche_date, **kwargs)

        ds[f'p_{track}_{pol}_empirical'] = p
        ds[f'p_{track}_{pol}_empirical'].attrs = {'units': '1', 'source': 'sarvalanche', 'product': 'orbit_empirical_probabilities'}
        ds[f'd_{track}_{pol}_empirical'] = d
        ds[f'd_{track}_{pol}_empirical'].attrs = {'units': 'dB', 'source': 'sarvalanche', 'product': 'orbit_backscatter_change'}
        prob_results.append(p)
        change_results.append(d)
        resolution_weights.append(ds['w_resolution'].sel(static_track=track))
        pol_weights.append(get_polarization_weights(pol))
        track_pol_labels.append(f"{track}_{pol}")

    if not prob_results:
        raise ValueError('No results generated by empirical pipeline.')

    prob_clean = [r.drop_vars(['track', 'direction'], errors='ignore') for r in prob_results]
    change_clean = [r.drop_vars(['track', 'direction'], errors='ignore') for r in change_results]
    probs = xr.concat(prob_clean, dim="track_pol").assign_coords(track_pol=track_pol_labels)
    changes = xr.concat(change_clean, dim="track_pol").assign_coords(track_pol=track_pol_labels)
    resolution_weights = xr.concat(resolution_weights, dim='track_pol').assign_coords(track_pol=track_pol_labels)

    # Convert pol_weights list to DataArray
    pol_weights = xr.DataArray(
        np.array(pol_weights),
        dims=['track_pol'],
        coords={'track_pol': track_pol_labels},
        name='w_polarization'
    )

    # Combine weights (normalizes to sum to 1.0)
    combined_weights = combine_weights(resolution_weights, pol_weights, dim='track_pol')

    # Validate the final combined weights
    if validate_weights:
        validate_weights_sum_to_one(combined_weights, dim='track_pol')

    # Combine probabilities
    # Use agreement boosting - boosts confidence when multiple sources agree
    p_empirical = combine_probabilities(
        probs,
        weights=combined_weights,
        method = 'log_odds',
        dim='track_pol',
        min_prob_threshold=min_prob_threshold,
        agreement_strength=agreement_strength,
        agreement_boosting = use_agreement_boosting
    )

    # Combine raw backscatter changes via weighted mean
    d_empirical = weighted_mean(changes, combined_weights, dim='track_pol')

    log.debug(
        "calculate_empirical_backscatter_probability: %d track/pol combos processed, "
        "probability range [%.4f, %.4f], change range [%.4f, %.4f]",
        len(track_pol_labels),
        float(p_empirical.min()),
        float(p_empirical.max()),
        float(d_empirical.min()),
        float(d_empirical.max()),
    )

    p_empirical.attrs = {
        'source': 'sarvalanche',
        'units': 'probability',
        'product': 'probability',
        'method': 'empirical_backscatter',
        'agreement_boosting': int(use_agreement_boosting),
    }

    if use_agreement_boosting:
        p_empirical.attrs['agreement_strength'] = agreement_strength
        p_empirical.attrs['min_prob_threshold'] = min_prob_threshold

    d_empirical.attrs = {
        'source': 'sarvalanche',
        'units': 'dB',
        'product': 'backscatter_change',
        'method': 'empirical_weighted_mean',
    }

    return p_empirical, d_empirical