
import numpy as np
import xarray as xr

from sarvalanche.utils.generators import iter_track_pol_combinations

# from sarvalanche.probabilities.ecdf import compute_track_ecdf_probability
from sarvalanche.probabilities.empirical import compute_track_empirical_probability

from sarvalanche.probabilities.combine import combine_probabilities_with_agreement
from sarvalanche.weights.combinations import combine_weights
from sarvalanche.weights.polarizations import get_polarization_weights

from sarvalanche.utils.validation import validate_weights_sum_to_one

# Empirical pipeline - FULL SCENE
def calculate_empirical_backscatter_probability(
    ds: xr.Dataset,
    avalanche_date: np.datetime64,
    use_agreement_boosting: bool = True,
    agreement_strength: float = 0.8,
    min_prob_threshold: float = 0.1,
    validate_weights: bool = True,
    **kwargs
) -> xr.DataArray:
    """
    Calculate full-scene avalanche probability using empirical backscatter change method.

    Combines probabilities across all track/polarization combinations with optional
    agreement boosting.

    Parameters
    ----------
    ds : xr.Dataset
        Dataset containing backscatter data and weights
    avalanche_date : np.datetime64
        Date of avalanche event
    use_agreement_boosting : bool
        If True, boost probability when multiple tracks/pols agree (default: True)
    agreement_strength : float
        How much to boost for full agreement (0.0-1.0, default: 0.8)
        Only used if use_agreement_boosting=True
    min_prob_threshold : float
        Minimum probability to consider as "detection" for agreement (default: 0.1)
        Only used if use_agreement_boosting=True
    validate_weights : bool
        If True, validate that weights sum to 1.0
    **kwargs
        Additional arguments passed to compute_track_empirical_probability

    Returns
    -------
    xr.DataArray
        Combined avalanche probability (0-1) across all track/pol combinations

    Examples
    --------
    >>> # Standard weighted average (no agreement boosting)
    >>> p = calculate_empirical_backscatter_probability(
    ...     ds, avalanche_date, use_agreement_boosting=False
    ... )

    >>> # With agreement boosting (recommended)
    >>> p = calculate_empirical_backscatter_probability(
    ...     ds, avalanche_date, use_agreement_boosting=True, agreement_strength=0.8
    ... )
    """
    results = []
    resolution_weights = []
    pol_weights = []
    track_pol_labels = []

    for track, pol, da, weights in iter_track_pol_combinations(ds, include_weights=False):
        p = compute_track_empirical_probability(da, avalanche_date, **kwargs)
        ds[f'p_{track}_{pol}_empirical'] = p
        ds[f'p_{track}_{pol}_empirical'].attrs = {'units': '1', 'source': 'sarvalanche', 'product': 'orbit_emperical_probabilities'}
        results.append(p)
        resolution_weights.append(ds['w_resolution'].sel(static_track=track))
        pol_weights.append(get_polarization_weights(pol))
        track_pol_labels.append(f"{track}_{pol}")

    if not results:
        raise ValueError('No results generated by empirical pipeline.')

    # Stack everything
    probs = xr.concat(results, dim="track_pol").assign_coords(track_pol=track_pol_labels)
    resolution_weights = xr.concat(resolution_weights, dim='track_pol').assign_coords(track_pol=track_pol_labels)

    # Convert pol_weights list to DataArray
    pol_weights = xr.DataArray(
        np.array(pol_weights),
        dims=['track_pol'],
        coords={'track_pol': track_pol_labels},
        name='w_polarization'
    )

    # Combine weights (normalizes to sum to 1.0)
    combined_weights = combine_weights(resolution_weights, pol_weights, dim='track_pol')

    # Validate the final combined weights
    if validate_weights:
        validate_weights_sum_to_one(combined_weights, dim='track_pol')

    # Combine probabilities
    if use_agreement_boosting:
        # Use agreement boosting - boosts confidence when multiple sources agree
        p_empirical = combine_probabilities_with_agreement(
            probs,
            weights=combined_weights,
            dim='track_pol',
            min_prob_threshold=min_prob_threshold,
            agreement_strength=agreement_strength,
        )
    else:
        # Simple weighted average
        p_empirical = (probs * combined_weights).sum(dim='track_pol')

    p_empirical.attrs = {
        'source': 'sarvalanche',
        'units': 'probability',
        'product': 'probability',
        'method': 'empirical_backscatter',
        'agreement_boosting': int(use_agreement_boosting),
    }

    if use_agreement_boosting:
        p_empirical.attrs['agreement_strength'] = agreement_strength
        p_empirical.attrs['min_prob_threshold'] = min_prob_threshold

    return p_empirical